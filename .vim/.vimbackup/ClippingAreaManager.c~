/** 
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 * KOMATSU "Front Runner" / AHS Embeded Controller Software
 * Copyright (C) 2006 Komatsu Ltd. All rights reserved.
 * 
 *  $RCSfile: ClippingAreaManager.c,v $
 * $Revision: 1.1.1.1 $
 *   $Author: tojima $
 *     $Date: 2005/07/06 06:36:19 $
 *    $State: Exp $
 *
 *    @brief: Safety Controller
 *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*/

#include "ClippingAreaManager.h"
#include "ModeManager.h"
#include "TruckInfo.h"
#include "VirtualBank.h"
#include "Course.h"
#include "WarningManager.h"
#include "ErrorManager.h"
#include "AhsTools.h"
#include "RpcManager.h"
#include "AppMain.h"
#include "TrajDirection.h"
#include "TruckConfigTable.h"
#include "AhsLocation.h"

#include "AhsAuxDevice.h"
#include "AppNvram.h"
#include "AppIfdef.h"

//#define ZONE_WIDTH_INSPECTION   6000
#define ZONE_WIDTH_INSPECTION   9000
#define ZONE_WIDTH_REAR_INSPECTION 4000
#define ZONE_WIDTH_ANGLE_CALIB  9000
#define ZONE_WIDTH_ANGLE_CALIB_ESR  12000
#define ZONE_WIDTH_RANGE_CALIB  5500
#define ZONE_WIDTH_RANGE_CALIB_ESR 17000
#define ZONE_WIDTH_TEST         20000


#define DECEL_G 784 //ClippingArea定義の設定減速度 0.08G 784mm/sec

#define CLIP_MIN_DISTANCE  60    // 最低60点（60m）

typedef struct{
    sint32 x[NUM_ZONE_VERTEX];
    sint32 y[NUM_ZONE_VERTEX];
    sint32 minx;                 /** クリッピングエリアのX座標の最小値 [mm] */
    sint32 miny;                 /**   */
    sint32 maxx;                 /**   */
    sint32 maxy;                 /**   */
    sint32 zoneCenterX1;
    sint32 zoneCenterX2;
    sint32 zoneCenterY1;
    sint32 zoneCenterY2;
    uint32 index;
    sint8  segmentType;          /* 0:前進コース 1:後進コース 2:停止点  3:停止点（精度要） 4:停止点の一つ前*/
    sint8  reserved[3];
} StructZone;

/**
 * クリッピングエリアクラス属性定義
 */
typedef struct{
    StructZone zone[NUM_ZONE];       /** 車両前端によるクリッピングエリア */
    StructZone zoneRear[NUM_ZONE];   /** 後輪によるクリッピングエリア   2008/3/31 */
    sint16     num;                  /** クリッピングエリアの頂点数（Zoneの数） */
    sint16     speedLimit;
    ZoneType   type;                 /** クリッピングエリアタイプ */
    bool       printFlag;
    bool       useRearArea;          /** 後輪クリッピングエリアを使うかどうか */
    uint32     margin;
    uint32     endIndex;
    sint32     width;
    sint16     odsType;
} StructClippingArea;

/** 
 * オブジェクト定義
 */
static StructClippingArea clippingArea;

/** 
 * プライベート関数
 */
static void ClippingArea_ZoneClear(StructZone *pZone);
static void ClippingArea_Clear(void);
static void ClippingArea_StoreBankData(uint32 index, sint16 ii);
static void ClippingArea_SetZone(void);
static void ClippingArea_SetZoneData(uint32 startIndex, uint32 endIndex);
static uint16 ClippingArea_GetDecStpDist(void);
static void ClippingArea_CalcBounds(StructZone *zone);
static void ClippingArea_CalcSpeedLimit(void);
static void ClippingArea_CheckBuffer(void);
static sint32 ClippingArea_CalcLateralPosition(sint32 x, sint32 y, StructZone *pZone);
static void  ClippingArea_ChangeAbsolutePosition(StructZone *zone);
static sint16 ClippingArea_PrintfZoneData(sint16 index);
static bool ClippingArea_IsInsideZone(StructZone *zone, sint32 x, sint32 y);
static void ClippingArea_CalcFrontZone(StructBankData *pBank, StructBankData *pBankRear, sint16 ii);
static void ClippingArea_CalcRearZone(StructBankData *pBank, StructBankData *pBankRear, sint16 ii);
static void ClippingArea_SetZoneTestWithGlobalCoordinate(void);

//---------------------------------------------------------------------------
/**
 * 初期化
 */
//---------------------------------------------------------------------------
void ClippingArea_Init(void)
{
    ClippingArea_Clear();
    
    clippingArea.useRearArea = TRUE;       // デフォルトは前輪のみ
    clippingArea.margin      = 40;         // 40点
    clippingArea.endIndex    = 0xffffffff;
    
    clippingArea.odsType     = AppNvram_GetOdsType();
}
//---------------------------------------------------------------------------
/**
 * メイン（毎サイクル１回だけ実行すること）
 */
//---------------------------------------------------------------------------
void ClippingArea_Main(void)
{
    static sint16 printIndex = 0;

    // 自動モードならコースからクリッピングエリアを決める
    if( Mode_GetCurrentMode() == modeAuto )
    {
        clippingArea.type = zoneAutoRun;

        // クリッピングエリアの定義
        ClippingArea_SetZone();
        
        // クリッピングエリアによる速度制限
        ClippingArea_CalcSpeedLimit();
        
        // 走行中にクリッピングエリアが空になったら停止
        ClippingArea_CheckBuffer();
    }
    else if( Mode_GetCurrentMode() == modeManual )
    {
        if( ( clippingArea.type == zoneTest4 ) || ( clippingArea.type == zoneTestRear2 ) )
        {
             ClippingArea_SetZoneTestWithGlobalCoordinate();   // テスト用クリッピングエリア
        }
        else
        {
            //
        }
    }
    else
    {
        //
    }

    // ClippingArea情報のPrintf表示
    if( clippingArea.printFlag == ON )
    {
        if( AdtMain_GetMainCounter() % T_500MSEC ==0 )
        {
            if( ClippingArea_PrintfZoneData(printIndex++) == -1 )
            {
                clippingArea.printFlag = OFF;
            }
        }
    }
    else
    {
        printIndex = 0;
    }


    // モードが変わったら、とにかくクリッピングエリアをクリア
    if( Mode_GetCurrentMode() != Mode_GetPreviousMode() )
    {
        ClippingArea_Clear();
    }
    else
    {
        //
    }

}


//---------------------------------------------------------------------------
/**
 * クリッピングエリア内にあるかどうか
 * @param x 調べる点のX座標 [mm]
 * @param y 調べる点のY座標 [mm]
 * @param *latpos エリア中心からの横方向距離 [mm]
 * @param *segmentType 検知セグメントの種類
 * @retval ZONE_R_IN エリア内
 * @retval ZONE_F_IN エリア内
 * @retval ZONE_OUT  エリア外
 */
//---------------------------------------------------------------------------
sint16 ClippingArea_ZoneContains(sint32 x, sint32 y, sint32 *latpos, sint8 *segmentType)
{
    StructZone *zoneF,*zoneR;
    sint16 ii;
    bool retF,retR;

    *latpos = 0;
    
    /*
        前端クリッピングエリアと後輪エリアの両方に入っている場合があるが
        後輪エリアを優先する
    */

    for( ii=0; ii<clippingArea.num; ii++ )
    {
        // 自動走行以外は後輪クリッピングエリアは使わない
        if( clippingArea.useRearArea == TRUE && clippingArea.type == zoneAutoRun)
        {
            // まず後輪のクリッピングエリア内かどうか調べる
            zoneR = &clippingArea.zoneRear[ii];
            retR = ClippingArea_IsInsideZone( zoneR, x, y );
            if( retR == TRUE ) // 後輪エリア優先
            {
                // クリッピングエリア内の横方向の位置を計算する
                *latpos = ClippingArea_CalcLateralPosition(x,y,zoneR);
                
                // zoneの種類をセット
                *segmentType = zoneR->segmentType;
                
                return(ZONE_R_IN);
            }
            else
            {
                // do nothing
            }
        }

        // 後輪エリア内でなければ、前端エリアで調べる
        zoneF = &clippingArea.zone[ii];
        retF = ClippingArea_IsInsideZone( zoneF, x, y );
        if( retF == TRUE )
        {
            // クリッピングエリア内の横方向の位置を計算する
            *latpos = ClippingArea_CalcLateralPosition(x,y,zoneF);

            // zoneの種類をセット
            *segmentType = zoneF->segmentType;

            return(ZONE_F_IN);
        }
        else
        {
            // do nothing
        }
    }
    
    *segmentType = ZONE_UNDEFINED;

    // 外側
    return(ZONE_OUT);
}

//---------------------------------------------------------------------------
/**
 * @return クリッピングエリアのタイプ
 */
//---------------------------------------------------------------------------
ZoneType ClippingArea_GetZoneType(void)
{
    return(clippingArea.type);
}
sint32 ClippingArea_GetXR(sint16 ii)
{
    return(clippingArea.zone[ii].x[0]);
}
sint32 ClippingArea_GetYR(sint16 ii)
{
    return(clippingArea.zone[ii].y[0]);
}
sint32 ClippingArea_GetXL(sint16 ii)
{
    return(clippingArea.zone[ii].x[3]);
}
sint32 ClippingArea_GetYL(sint16 ii)
{
    return(clippingArea.zone[ii].y[3]);
}
sint32 ClippingArea_GetXR_Rear(sint16 ii)
{
    return(clippingArea.zoneRear[ii].x[0]);
}
sint32 ClippingArea_GetYR_Rear(sint16 ii)
{
    return(clippingArea.zoneRear[ii].y[0]);
}
sint32 ClippingArea_GetXL_Rear(sint16 ii)
{
    return(clippingArea.zoneRear[ii].x[3]);
}
sint32 ClippingArea_GetYL_Rear(sint16 ii)
{
    return(clippingArea.zoneRear[ii].y[3]);
}


sint16 ClippingArea_GetAreaNum(void)
{
    return(clippingArea.num);
}
uint32 ClippingArea_GetCourseIndex(sint16 ii)
{
    return(clippingArea.zone[ii].index);
}


uint32 ClippingArea_GetZoneCenterX1(sint16 ii)
{
    return(clippingArea.zone[ii].zoneCenterX1);
}
uint32 ClippingArea_GetZoneCenterY1(sint16 ii)
{
    return(clippingArea.zone[ii].zoneCenterY1);
}
uint32 ClippingArea_GetZoneCenterX2(sint16 ii)
{
    return(clippingArea.zone[ii].zoneCenterX2);
}
uint32 ClippingArea_GetZoneCenterY2(sint16 ii)
{
    return(clippingArea.zone[ii].zoneCenterY2);
}

uint32 ClippingArea_GetZoneRearCenterX1(sint16 ii)
{
    return(clippingArea.zoneRear[ii].zoneCenterX1);
}
uint32 ClippingArea_GetZoneRearCenterY1(sint16 ii)
{
    return(clippingArea.zoneRear[ii].zoneCenterY1);
}
uint32 ClippingArea_GetZoneRearCenterX2(sint16 ii)
{
    return(clippingArea.zoneRear[ii].zoneCenterX2);
}
uint32 ClippingArea_GetZoneRearCenterY2(sint16 ii)
{
    return(clippingArea.zoneRear[ii].zoneCenterY2);
}

uint8 ClippingArea_GetZoneSegmentType(sint16 ii)
{
    return(clippingArea.zone[ii].segmentType);
}

void ClippingArea_SetMergin(uint32 value)
{
    if( value < CLIP_MIN_DISTANCE )
    {
        clippingArea.margin = value;
    }
}

uint32 ClippineArea_GetEndIndex(void)
{
	uint32 index;
	
	if( clippingArea.num > 0 )
	{
		index = clippingArea.zone[clippingArea.num-1].index;
	}
	else
	{
		index = 0;
	}
	return(index);

//    return(clippingArea.endIndex);

}
//---------------------------------------------------------------------------
/**
 * テスト、点検用にダミーのクリッピングエリアをセットする
 * @param クリッピングエリアのタイプ
 */
//---------------------------------------------------------------------------
void ClippingArea_SetDummyZone(ZoneType type)
{
    sint32 xs, step, radarHeadPos;
    sint16 i;
    
    
    radarHeadPos = (sint32)AHT_OdsDistanceFromRearCenter(1);   // [mm]
    
    // マニュアルモードかメンテナンスモード以外では受け付けない
    if(  ( Mode_GetCurrentMode()==modeManual ) || (Mode_GetCurrentMode()==modeMaintenance ) )
    {
        clippingArea.type = type;

        if( clippingArea.type == zoneInspection )
        {
            xs    = radarHeadPos + 25000;  // レーダ先25m〜35m
            step  = 5000;
            clippingArea.width = ZONE_WIDTH_INSPECTION;   // 6.0*2 = 12m 
            clippingArea.num   = 2;
        }
        else if( clippingArea.type == zoneCalibration )
        {
            xs    = radarHeadPos + 27500;  // レーダ先27.5m〜32.5m
            step  = 5000;
            clippingArea.width = ZONE_WIDTH_ANGLE_CALIB;   // 9.0*2 = 18m 
            clippingArea.num   = 1;
            if( (clippingArea.odsType == ESRX3_MMR1CX2_SRRX4)||(clippingArea.odsType == ESRX3_MMR1CX2) )
            {
				clippingArea.width = ZONE_WIDTH_ANGLE_CALIB_ESR;
			}
        }
        else if( clippingArea.type == zoneRangeCalibration )
        {
            xs    = radarHeadPos + 47500;  // レーダ先47.5m〜52.5m
            step  = 5000;
            clippingArea.width = ZONE_WIDTH_RANGE_CALIB;   // 5.5*2 = 11m 
            clippingArea.num   = 1;
            if( (clippingArea.odsType == ESRX3_MMR1CX2_SRRX4)||(clippingArea.odsType == ESRX3_MMR1CX2) )
            {
				clippingArea.width = ZONE_WIDTH_RANGE_CALIB_ESR;
			}
        }
        else if( clippingArea.type == zoneTest )
        {
            xs    = radarHeadPos;  // レーダ先0m〜100m
            step  = 5000;
            clippingArea.width = (sint32)AHT_ClippingArea();   // 7*2 = 14m 
            clippingArea.num   = NUM_ZONE;
        }
        else if( clippingArea.type == zoneTest2 )
        {
            xs    = 0;      // 0m
            step  = 5000;
            clippingArea.width = (sint32)AHT_ClippingArea();   // 7*2 = 14m 
            clippingArea.num   = NUM_ZONE;
        }
        else if( clippingArea.type == zoneTest3 )
        {
            xs    = radarHeadPos;  // レーダ先0m〜100m
            step  = 5000;
            clippingArea.width = ZONE_WIDTH_TEST;   // 7*2 = 14m 
            clippingArea.num   = NUM_ZONE;
        }
        else if( clippingArea.type == zoneTest4 )
        {
            xs    = 0;                 // 0m
            step  = 5000;
//            clippingArea.width = ZONE_WIDTH_TEST;   // 7*2 = 14m 
//            clippingArea.width = (sint32)AHT_ClippingArea();   // 7*2 = 14m 
            clippingArea.width = ZONE_WIDTH_TEST;   // 7*2 = 14m 
            clippingArea.num   = NUM_ZONE;
        }
        else if( clippingArea.type == zoneTestRear )
        {
            xs    = 0;           // -30m
            step  = -5000;
//            clippingArea.width = ZONE_WIDTH_TEST;  // 7*2 = 14m 
            clippingArea.width = (sint32)AHT_ClippingArea();  // 7*2 = 14m 
            clippingArea.num   = 6;   // 6 x 5 = 30m
        }
        else if( clippingArea.type == zoneRearInspection )
        {
//            xs    = -10000;           // レーダ先5m〜20m
//            xs    =  -5000;           // レーダ先5m〜15m
//            step  =  -5000;
//            clippingArea.width = ZONE_WIDTH_INSPECTION;  // 9*2 = 18m 
            xs    =  -8000;           // レーダ先8m〜12m
            step  =  -2000;
            clippingArea.width = ZONE_WIDTH_REAR_INSPECTION;  // 4*2 = 8m 
            clippingArea.num   = 2;   // 2 x 2 = 4m
        }
        else if( clippingArea.type == zoneSrrInspection )
        {
//            xs    = AHT_GetMacomFC_DistanceFromRearCenter() + 10000;  // レーダ先10m〜20m
//            xs    = AHT_GetMacomFC_DistanceFromRearCenter() + 5000;  // レーダ先5m〜15m
//            step  = 5000;
            xs    = AHT_GetMacomFC_DistanceFromRearCenter() + 5000;  // レーダ先5m〜15m
            step  = 5000;
            clippingArea.width = ZONE_WIDTH_INSPECTION;   // 9*2 = 18m 
            clippingArea.num   = 2;
        }
        else if( clippingArea.type == zoneSrrCalibration )
        {
            xs    = AHT_GetMacomFC_DistanceFromRearCenter() + 5000;  // レーダ先5m〜10m
            step  = 5000;
            clippingArea.width = 10000;   // 10.0*2 = 20m 
            clippingArea.num   = 1;
        }
        else if( clippingArea.type == zoneTestRear2 )
        {
            xs    = 0;            // -30m
            step  = -5000;
            clippingArea.width = ZONE_WIDTH_TEST;   // 7*2 = 14m 
            clippingArea.num   = 6;    // 30m
        }
        else if( clippingArea.type == zoneLuxCalibration )
        {
            xs    = radarHeadPos + 27500;  // レーダ先27.5m〜32.5m
            step  = 5000;
            clippingArea.width = 5000;   // 5.0*2 = 10m 
            clippingArea.num   = 1;
        }
        else if( clippingArea.type == zoneNone )  // Zoneのクリア
        {
            ClippingArea_Clear();
            clippingArea.num   = 0;
            clippingArea.width = 0;
            return;
        }
        else
        {
            return;
        }

        // セット
        for( i=0; i<clippingArea.num; i++ )
        {
            clippingArea.zone[i].x[0] = xs + step*i;
            clippingArea.zone[i].x[1] = xs + step*(i+1);
            clippingArea.zone[i].x[2] = xs + step*(i+1);
            clippingArea.zone[i].x[3] = xs + step*i;
            
            clippingArea.zone[i].y[0] = -clippingArea.width;
            clippingArea.zone[i].y[1] = -clippingArea.width;
            clippingArea.zone[i].y[2] =  clippingArea.width;
            clippingArea.zone[i].y[3] =  clippingArea.width;
            
            clippingArea.zone[i].zoneCenterX1 = xs + step*i;
            clippingArea.zone[i].zoneCenterX2 = xs + step*(i+1);
            clippingArea.zone[i].zoneCenterY1 = 0;
            clippingArea.zone[i].zoneCenterY2 = 0;

            clippingArea.zone[i].index       = 0;

            if( i == clippingArea.num-1 )
            {
                clippingArea.zone[i].segmentType = ZONE_ACCURATE_STOP;
            }
            else
            {
                if( ( clippingArea.type == zoneTestRear ) 
                 || ( clippingArea.type == zoneTestRear2 ) 
                 || ( clippingArea.type == zoneRearInspection ) 
                 )
                {
                    clippingArea.zone[i].segmentType = ZONE_MOVE_REVERSE;
                }
                else
                {
                    clippingArea.zone[i].segmentType = ZONE_MOVE_FORWARD;
                }
            }

            // 絶対座標でのクリッピングエリア
            if( (clippingArea.type == zoneTest2) 
             || (clippingArea.type == zoneTest4) 
             || (clippingArea.type == zoneTestRear2) 
              )
            {
                // 車両の方位角、XY座標だけ変換する
                ClippingArea_ChangeAbsolutePosition(&clippingArea.zone[i]);

                // クリッピングエリアの最大値、最小値
                ClippingArea_CalcBounds(&clippingArea.zone[i]);
            }

            // クリッピングエリアの最大値、最小値
            ClippingArea_CalcBounds(&clippingArea.zone[i]);
        }
    }
}


//---------------------------------------------------------------------------
/*
 * @return speed [mm/s]
 */
//---------------------------------------------------------------------------
sint16 ClippingArea_GetSpeedLimit(void)
{
    return(clippingArea.speedLimit);
}

//---------------------------------------------------------------------------
/**
 * ClippingArea情報をPrintf表示する
 */
//---------------------------------------------------------------------------
void ClippingArea_ShowInfo(void)
{
    clippingArea.printFlag = ON;
}
//---------------------------------------------------------------------------
/**
 *
 */
//---------------------------------------------------------------------------
void ClippingArea_UseRearArea(bool flag)
{
    clippingArea.useRearArea = flag;
}
//---------------------------------------------------------------------------
/**
 * @return クリッピングエリア幅 [単位 10cm]
 */
//---------------------------------------------------------------------------
uint8 ClippingArea_GetZoneWidth(ZoneType type)
{
    uint8 width;
    
    if( clippingArea.type == zoneAutoRun )
    {
        width = 0xff;
    }
    else
    {
        width = (uint8)(clippingArea.width / 100);
    }

    return(width);
    
}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
// プライベート関数
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
/**
 * クリッピングエリアを削除
 */
//---------------------------------------------------------------------------
void ClippingArea_ZoneClear(StructZone *pZone)
{
    int j;

    for( j=0; j < NUM_ZONE_VERTEX; j++ )
    {
        pZone->x[j] = 0;
        pZone->y[j] = 0;
    }

    pZone->zoneCenterX2 = 0;
    pZone->zoneCenterY2 = 0;
    pZone->zoneCenterX1 = 0;
    pZone->zoneCenterY1 = 0;
    pZone->index        = 0;
    pZone->segmentType  = ZONE_MOVE_FORWARD;

    pZone->minx =  LONG_MAX;
    pZone->maxx =  LONG_MIN;
    pZone->miny =  LONG_MAX;
    pZone->maxy =  LONG_MIN;

}

void ClippingArea_Clear(void)
{
    int i;

    clippingArea.type = zoneNone;
    clippingArea.num  = 0;
    clippingArea.speedLimit = NO_SPEED_LIMIT;
    clippingArea.printFlag  = FALSE;

    for( i=0; i < NUM_ZONE; i++ )
    {
        ClippingArea_ZoneClear(&clippingArea.zone[0]);
        ClippingArea_ZoneClear(&clippingArea.zoneRear[0]);
    }
}
//---------------------------------------------------------------------------
/**
 * 仮想土手データをクリッピングエリアバッファにストアする
 *
 * （クリッピングエリア頂点配列の並び方）
 *   3   2
 *             ->進行方向
 *   0   1
 */
//---------------------------------------------------------------------------
void ClippingArea_StoreBankData(uint32 index, sint16 ii)
{
    StructBankData *pBank;
    StructBankData *pBankRear;
    bool stopFlag;

    // バッファオーバーフロー
    if( ii >= NUM_ZONE ) return;
    
    // コースデータがない（土手もない）
    if( Course_isValid(index) == FALSE ) return;

    // 仮想土手情報の取得
    pBank     = Bank_GetRadarBank(index);
    pBankRear = Bank_GetRearBank(index);

    // 対応するコースのインデックス
    clippingArea.zone[ii].index     = index;
    clippingArea.zoneRear[ii].index = index;

	// クリッピングエリア作成
	ClippingArea_CalcFrontZone(pBank, pBankRear, ii);
	ClippingArea_CalcRearZone(pBank, pBankRear, ii);

    // セグメントの種類をセット
    stopFlag = FALSE;

    // 精度必要停止点を含んでいるかどうか（エッジ or クラッシャ）
    if( AhsLocation_IsStopAccuracyRequired(index) == TRUE )
    {
        clippingArea.zone[ii].segmentType     = ZONE_ACCURATE_STOP;
        clippingArea.zoneRear[ii].segmentType = ZONE_ACCURATE_STOP;
        stopFlag = TRUE;
    }
    else
    {
        if( Course_GetDirection(index) == MOVE_FORWARD )
        {
            clippingArea.zone[ii].segmentType     = ZONE_MOVE_FORWARD;
            clippingArea.zoneRear[ii].segmentType = ZONE_MOVE_FORWARD;
        }
        else if( Course_GetDirection(index) == MOVE_BACKWARD )
        {
            clippingArea.zone[ii].segmentType     = ZONE_MOVE_REVERSE;
            clippingArea.zoneRear[ii].segmentType = ZONE_MOVE_REVERSE;
        }
        else
        {
            clippingArea.zone[ii].segmentType     = ZONE_NORMAL_STOP;
            clippingArea.zoneRear[ii].segmentType = ZONE_NORMAL_STOP;
            stopFlag = TRUE;
        }
    }

    // 一つ前
    if( ( ii >= 1 ) && ( stopFlag == TRUE ) )
    {
        clippingArea.zone[ii-1].segmentType     = ZONE_BEFORE_STOP;
        clippingArea.zoneRear[ii-1].segmentType = ZONE_BEFORE_STOP;
    }
    else
    {
        // do nothing
    }

    // 一つの矩形エリアを作るには、最低２点分の土手が必要
    clippingArea.num++;

    // クリッピングエリアの最大値最小値を求める
    ClippingArea_CalcBounds(&clippingArea.zone[ii]);
    ClippingArea_CalcBounds(&clippingArea.zoneRear[ii]);
}

//---------------------------------------------------------------------------
/**
 * 車両前端でのクリッピングエリアの計算
 */
//---------------------------------------------------------------------------
void ClippingArea_CalcFrontZone(StructBankData *pBank, StructBankData *pBankRear, sint16 ii)
{
    uint32 currentIndex;

	// 現在のインデックス
	currentIndex = TruckInfo_GetCurrentIndex();

    if( ii == 0 ) // 最初の点
    {
		if( Course_GetDirection(currentIndex) == MOVE_FORWARD )
		{
	        clippingArea.zone[ii].x[0] = pBankRear->xr;   
	        clippingArea.zone[ii].x[3] = pBankRear->xl;
	        clippingArea.zone[ii].y[0] = pBankRear->yr;
	        clippingArea.zone[ii].y[3] = pBankRear->yl;

	        clippingArea.zone[ii].x[1] = pBank->xr; 
	        clippingArea.zone[ii].x[2] = pBank->xl;
	        clippingArea.zone[ii].y[1] = pBank->yr;
	        clippingArea.zone[ii].y[2] = pBank->yl;

		}
		else // 後進時
		{
	        clippingArea.zone[ii].x[0] = pBank->xr;   
	        clippingArea.zone[ii].x[3] = pBank->xl;
	        clippingArea.zone[ii].y[0] = pBank->yr;
	        clippingArea.zone[ii].y[3] = pBank->yl;

	        clippingArea.zone[ii].x[1] = pBankRear->xr; // これは後で上書き
	        clippingArea.zone[ii].x[2] = pBankRear->xl;
	        clippingArea.zone[ii].y[1] = pBankRear->yr;
	        clippingArea.zone[ii].y[2] = pBankRear->yl;
		}

        clippingArea.zone[ii].zoneCenterX1 = (clippingArea.zone[ii].x[0] +  clippingArea.zone[ii].x[3]) / 2;
        clippingArea.zone[ii].zoneCenterY1 = (clippingArea.zone[ii].y[0] +  clippingArea.zone[ii].y[3]) / 2;

        clippingArea.zone[ii].zoneCenterX2 = (clippingArea.zone[ii].x[1] +  clippingArea.zone[ii].x[2]) / 2;
        clippingArea.zone[ii].zoneCenterY2 = (clippingArea.zone[ii].y[1] +  clippingArea.zone[ii].y[2]) / 2;
    }
    else
    {
		if( Course_GetDirection(currentIndex) == MOVE_FORWARD )
		{
	        clippingArea.zone[ii].x[0] = clippingArea.zone[ii-1].x[1];
	        clippingArea.zone[ii].x[3] = clippingArea.zone[ii-1].x[2];
	        clippingArea.zone[ii].y[0] = clippingArea.zone[ii-1].y[1];
	        clippingArea.zone[ii].y[3] = clippingArea.zone[ii-1].y[2];

	        clippingArea.zone[ii].x[1] = pBank->xr;
	        clippingArea.zone[ii].x[2] = pBank->xl;
	        clippingArea.zone[ii].y[1] = pBank->yr;
	        clippingArea.zone[ii].y[2] = pBank->yl;
		}
		else
		{
	        clippingArea.zone[ii].x[0] = pBank->xr;
	        clippingArea.zone[ii].x[3] = pBank->xl;
	        clippingArea.zone[ii].y[0] = pBank->yr;
	        clippingArea.zone[ii].y[3] = pBank->yl;

	        clippingArea.zone[ii].x[1] = pBankRear->xr;  // これは後で上書き
	        clippingArea.zone[ii].x[2] = pBankRear->xl;
	        clippingArea.zone[ii].y[1] = pBankRear->yr;
	        clippingArea.zone[ii].y[2] = pBankRear->yl;

			// 一つ前を上書き
	        clippingArea.zone[ii-1].x[1] = clippingArea.zone[ii].x[0];
	        clippingArea.zone[ii-1].x[2] = clippingArea.zone[ii].x[3];
	        clippingArea.zone[ii-1].y[1] = clippingArea.zone[ii].y[0];
	        clippingArea.zone[ii-1].y[2] = clippingArea.zone[ii].y[3];

	        clippingArea.zone[ii-1].zoneCenterX2 = (clippingArea.zone[ii-1].x[1] +  clippingArea.zone[ii-1].x[2]) / 2;
	        clippingArea.zone[ii-1].zoneCenterY2 = (clippingArea.zone[ii-1].y[1] +  clippingArea.zone[ii-1].y[2]) / 2;
		}

        clippingArea.zone[ii].zoneCenterX1 = (clippingArea.zone[ii].x[0] +  clippingArea.zone[ii].x[3]) / 2;
        clippingArea.zone[ii].zoneCenterY1 = (clippingArea.zone[ii].y[0] +  clippingArea.zone[ii].y[3]) / 2;

        clippingArea.zone[ii].zoneCenterX2 = (clippingArea.zone[ii].x[1] +  clippingArea.zone[ii].x[2]) / 2;
        clippingArea.zone[ii].zoneCenterY2 = (clippingArea.zone[ii].y[1] +  clippingArea.zone[ii].y[2]) / 2;
        
    }
}



//---------------------------------------------------------------------------
/**
 * 後輪位置でのクリッピングエリアの計算
 */
//---------------------------------------------------------------------------
void ClippingArea_CalcRearZone(StructBankData *pBank, StructBankData *pBankRear, sint16 ii)
{
    uint32 currentIndex;

	// 現在のインデックス
	currentIndex = TruckInfo_GetCurrentIndex();

    if( ii == 0 ) // 最初の点
    {
        clippingArea.zoneRear[ii].x[0] = pBankRear->xr;
        clippingArea.zoneRear[ii].x[3] = pBankRear->xl;
        clippingArea.zoneRear[ii].y[0] = pBankRear->yr;
        clippingArea.zoneRear[ii].y[3] = pBankRear->yl;

		// 前進コースか後進コースかで、終点の形状が変わる
		if( Course_GetDirection(currentIndex) == MOVE_FORWARD )
		{
	        clippingArea.zoneRear[ii].x[1] = pBank->xr;  // これは後で上書きされる
	        clippingArea.zoneRear[ii].x[2] = pBank->xl;
	        clippingArea.zoneRear[ii].y[1] = pBank->yr;
	        clippingArea.zoneRear[ii].y[2] = pBank->yl;
		}
		else
		{
	        clippingArea.zoneRear[ii].x[1] = pBankRear->xr;
	        clippingArea.zoneRear[ii].x[2] = pBankRear->xl;
	        clippingArea.zoneRear[ii].y[1] = pBankRear->yr;
	        clippingArea.zoneRear[ii].y[2] = pBankRear->yl;

		}

        clippingArea.zoneRear[ii].zoneCenterX1 = (clippingArea.zoneRear[ii].x[0] +  clippingArea.zoneRear[ii].x[3]) / 2;
        clippingArea.zoneRear[ii].zoneCenterY1 = (clippingArea.zoneRear[ii].y[0] +  clippingArea.zoneRear[ii].y[3]) / 2;

        clippingArea.zoneRear[ii].zoneCenterX2 = (clippingArea.zoneRear[ii].x[1] +  clippingArea.zoneRear[ii].x[2]) / 2;
        clippingArea.zoneRear[ii].zoneCenterY2 = (clippingArea.zoneRear[ii].y[1] +  clippingArea.zoneRear[ii].y[2]) / 2;

    }
    else
    {
        clippingArea.zoneRear[ii].x[0] = pBankRear->xr;
        clippingArea.zoneRear[ii].x[3] = pBankRear->xl;
        clippingArea.zoneRear[ii].y[0] = pBankRear->yr;
        clippingArea.zoneRear[ii].y[3] = pBankRear->yl;

		if( Course_GetDirection(currentIndex) == MOVE_FORWARD )
		{
	        clippingArea.zoneRear[ii].x[1] = pBank->xr;  // これは後で上書きされる
	        clippingArea.zoneRear[ii].x[2] = pBank->xl;
	        clippingArea.zoneRear[ii].y[1] = pBank->yr;
	        clippingArea.zoneRear[ii].y[2] = pBank->yl;
		}
		else
		{
	        clippingArea.zoneRear[ii].x[1] = pBankRear->xr;  // これは後で上書きされる
	        clippingArea.zoneRear[ii].x[2] = pBankRear->xl;
	        clippingArea.zoneRear[ii].y[1] = pBankRear->yr;
	        clippingArea.zoneRear[ii].y[2] = pBankRear->yl;
		}

        clippingArea.zoneRear[ii].zoneCenterX1 = (clippingArea.zoneRear[ii].x[0] +  clippingArea.zoneRear[ii].x[3]) / 2;
        clippingArea.zoneRear[ii].zoneCenterY1 = (clippingArea.zoneRear[ii].y[0] +  clippingArea.zoneRear[ii].y[3]) / 2;

        clippingArea.zoneRear[ii].zoneCenterX2 = (clippingArea.zoneRear[ii].x[1] +  clippingArea.zoneRear[ii].x[2]) / 2;
        clippingArea.zoneRear[ii].zoneCenterY2 = (clippingArea.zoneRear[ii].y[1] +  clippingArea.zoneRear[ii].y[2]) / 2;

		// 一つ前を上書き
        clippingArea.zoneRear[ii-1].x[1] = clippingArea.zoneRear[ii].x[0];
        clippingArea.zoneRear[ii-1].x[2] = clippingArea.zoneRear[ii].x[3];
        clippingArea.zoneRear[ii-1].y[1] = clippingArea.zoneRear[ii].y[0];
        clippingArea.zoneRear[ii-1].y[2] = clippingArea.zoneRear[ii].y[3];

        clippingArea.zoneRear[ii-1].zoneCenterX2 = (clippingArea.zoneRear[ii-1].x[1] +  clippingArea.zoneRear[ii-1].x[2]) / 2;
        clippingArea.zoneRear[ii-1].zoneCenterY2 = (clippingArea.zoneRear[ii-1].y[1] +  clippingArea.zoneRear[ii-1].y[2]) / 2;
    }
    
}

//---------------------------------------------------------------------------
/**
 * 自動走行時のクリッピングエリアを定義する
 *
 * 2007/06/26 : AHS Ver1.2 002.000.000 , Shibata
 */
//---------------------------------------------------------------------------
void ClippingArea_SetZone(void)
{
    uint32 currentIndex,speedZeroIndex,decelStopIndex,trajEndIndex;
//  uint32 zeroPlusAlphaIndex;
    uint32 switchBackIndex;

    currentIndex   = TruckInfo_GetCurrentIndex();         // 現在インデックス
    speedZeroIndex = Course_GetSpeedProfileZeroIndex();   // 速度０の点
    decelStopIndex = currentIndex + ClippingArea_GetDecStpDist(); //減速度から割り出した停止点
    trajEndIndex   = Course_GetTrajectoryEndIndex();     //トラジェクトリエンドインデックス
    
//  zeroPlusAlphaIndex = speedZeroIndex + clippingArea.margin;  // 速度０の点＋アルファの点
    switchBackIndex    = TrjDir_GetSwBackIndex();               // 

    // クリッピングエリアは毎回クリア
    clippingArea.num = 0;

    // クリッピングエリアに土手データをストアしていく
    // 後進コースもクリッピングエリアを作る
    // 車両が停車したら、クリッピングエリアはなし
    if( TruckInfo_GetMovingStatus() == MOVE_STOPPED )
    {
        clippingArea.endIndex = speedZeroIndex;
        return;
    }


#ifdef _CLIP_AREA_EXTEND_
    // SpeedProfileの終点まで60m以上あれば、SpeedProfileEndまで
    if( (sint32)(speedZeroIndex-currentIndex) >= CLIP_MIN_DISTANCE )
    {
        clippingArea.endIndex = speedZeroIndex;
    }
    // SpeedProfileの終点まで60-margin以下ならSpeedProfileEnd + margin
    else if( (sint32)(speedZeroIndex-currentIndex) < (CLIP_MIN_DISTANCE-clippingArea.margin) )
    {
        clippingArea.endIndex = speedZeroIndex + clippingArea.margin;
    }
    // (60-margin) 以上、60m以下なら、currentIndex+60mまで
    else
    {
        clippingArea.endIndex = currentIndex + CLIP_MIN_DISTANCE;
    }


    // ただし、上記でも求めたインデックスよりdecelStopIndexのほうが先ならそこまで
    if( (sint32)(decelStopIndex - clippingArea.endIndex) > 0 )
    {
        clippingArea.endIndex = decelStopIndex;
    }

    // ただし、上記でも求めたインデックスより停止点が手前なら、停止点まで
    if( (sint32)(clippingArea.endIndex - switchBackIndex) > 0 )
    {
        clippingArea.endIndex = switchBackIndex;
    }

    // クリッピングエリアは、現在インデックスから、上で求めたインデックスまでとする
    ClippingArea_SetZoneData(currentIndex, clippingArea.endIndex);

    
#else ///#ifdef _CLIP_AREA_EXTEND_  // オリジナル

    //speedZeroIndexがdecelStopIndexより大きいとき、またはspeedZeroIndex + 1が後進のとき
    //speedZeroIndexまでとする
    if( (sint32)(speedZeroIndex - decelStopIndex) > 0 ||
        Course_GetDirection(speedZeroIndex + 1) == MOVE_BACKWARD )
    {
        clippingArea.endIndex = speedZeroIndex;
    }
    //trajEndIndexがdecelStopIndexより大きいとき、decelStopIndexまでとする
    else if( (sint32)(trajEndIndex - decelStopIndex) > 0 )
    {
        clippingArea.endIndex = decelStopIndex;
    }
    //decelStopIndexが最も大きいとき、trajEndIndexまでとする
    else
    {
        clippingArea.endIndex = trajEndIndex;
    }

    ClippingArea_SetZoneData(currentIndex, clippingArea.endIndex);

#endif ///#ifdef _CLIP_AREA_EXTEND_

}

//---------------------------------------------------------------------------
/**
 * startIndexからendIndexまでのクリッピングエリアを作成する(最大NUM_ZONEまで)
 */
//---------------------------------------------------------------------------
void ClippingArea_SetZoneData(uint32 startIndex, uint32 endIndex)
{
    sint16 i;
    uint32 index;
    sint32 dindex;
    
    index = startIndex;

    for( i=0; i < NUM_ZONE; i++ )
    {
        ClippingArea_StoreBankData(index, i);
        index += 5;

		// 最後のセグメントは必ず5m残すようにする
		// Endまであと10点なければ、最後の一つ前のセグメントの大きさを調節する
        // endIndexは必ず使う
		dindex = (sint32)(endIndex - index);
/*
		if( ( 0 < dindex ) && ( dindex < 5 ) )
		{
			index -= (5-dindex);
            ClippingArea_StoreBankData(index, i+1);  // 最後の一つ前

			index = endIndex;
            ClippingArea_StoreBankData(index, i+2);  // 最後のセグメント

            break;
		}
		else if( dindex <= 0 )
		{
			index = endIndex;
            ClippingArea_StoreBankData(index, i+1);  // 最後のセグメント

            break;
		}
*/
		if( dindex <= 0 )
		{
			index = endIndex;
            ClippingArea_StoreBankData(index, i+1);  // 最後のセグメント

            break;
		}
		else
		{
			// do nothing
		}
    }
}

//---------------------------------------------------------------------------
/**
 * 現在の車速から割り出した減速度DECEL_G(mm/sec)での停車距離を求める
 */
//---------------------------------------------------------------------------
uint16 ClippingArea_GetDecStpDist(void)
{
    sint32 speed; //現在車速
    sint32 decelStopDist; //停止距離

    speed = (sint32)TruckInfo_GetSpeed();
    
    //停止距離 = (現在車速^2)/(2*減速度)
    decelStopDist = speed*speed / (2*DECEL_G);
    
    //decelStopDistが1000より小さく、かつ止まってなければ1000とする
    if(decelStopDist != 0 && decelStopDist < 1000){
        decelStopDist = 1000;
    }
    
    return((uint16)(decelStopDist/1000));
}

//---------------------------------------------------------------------------
/**
 * 
 */
//---------------------------------------------------------------------------
void ClippingArea_CalcBounds(StructZone *zone)
{
    sint16   i;
    sint32    x,y;

    zone->minx = LONG_MAX;
    zone->maxx = LONG_MIN;
    zone->miny = LONG_MAX;
    zone->maxy = LONG_MIN;

    for( i=0; i < NUM_ZONE_VERTEX; i++ )
    {
        x = zone->x[i];
        zone->minx = l_kmin(zone->minx, x);
        zone->maxx = l_kmax(zone->maxx, x);

        y = zone->y[i];
        zone->miny = l_kmin(zone->miny, y);
        zone->maxy = l_kmax(zone->maxy, y);
    }
}

//---------------------------------------------------------------------------
/**
 * クリッピングエリアの長さによる速度制限の計算
 * 40m 20km/h   5556mm/s
 * 60m 40km/h  11111mm/s
 * 80m 60km/h  16667mm/s
 */
//---------------------------------------------------------------------------
void ClippingArea_CalcSpeedLimit(void)
{
    sint16 direction;
    float32  range;
    float32  speed;

    // 進行方向
    direction = Course_GetDirection(TruckInfo_GetCurrentIndex());
    
    // 前進コース以外では速度制限なし
    if( direction == MOVE_STOPPED )
    {
        clippingArea.speedLimit = NO_SPEED_LIMIT;
    }
    else if( direction == MOVE_BACKWARD )
    {
        clippingArea.speedLimit = direction * NO_SPEED_LIMIT;
    }
    else if( direction == MOVE_FORWARD )
    {
        range = (float32)(5*clippingArea.num);   // 1つのエリア長さを5mとして計算
        
        speed = 277.775*range-5555.0;
        if( speed < 5556 ) 
        {
            speed = 5556;
        }
        else if(speed > 16667) 
        {
            speed = 16667;
        }
        
        clippingArea.speedLimit = direction * (sint16)speed;
    }
}

//---------------------------------------------------------------------------
/**
 * 自動モードのときだけ実行
 */
//---------------------------------------------------------------------------
void ClippingArea_CheckBuffer(void)
{

    //前進中にクリッピングエリアが1以下になったらエラー
    if(TruckInfo_GetSpeed() > 0)
    {
        if( (clippingArea.num <= 1) && (TruckInfo_GetMovingStatus() != MOVE_STOPPED) )
        {
            Error_Set(E_ZONE_BUFFER_EMPTY);
        }
    }
    
    
    // 後進は？？？
}

//---------------------------------------------------------------------------
/**
 * 検知したターゲットのクリッピングエリア内の横位置を計算する
 * @return  右側（−）、左側（＋） [mm]
 */
//---------------------------------------------------------------------------
sint32 ClippingArea_CalcLateralPosition(sint32 x, sint32 y, StructZone *pZone)
{
    float32 x1,x2,y1,y2;
    float32 a,b,c;
    float32 len;

    // 直線の方程式を求める
    x1 = (float32)pZone->zoneCenterX1;
    x2 = (float32)pZone->zoneCenterX2;
    y1 = (float32)pZone->zoneCenterY1;
    y2 = (float32)pZone->zoneCenterY2;

    // 点と直線の距離の公式から距離が求まる
    // a*x + b*y + c = 0;
    //
    a = y2 - y1;
    b = x1 - x2;
    c = y1 * (x2 - x1) - x1 * (y2 - y1);

    // y軸に平行の場合は距離はX座標そのもの
    if( pZone->zoneCenterX1 == pZone->zoneCenterX2 )
    {
        len = (float32)(x - pZone->zoneCenterX1);
    }
    // x軸に平行の場合は距離はy座標そのもの
    else if( pZone->zoneCenterY1 == pZone->zoneCenterY2 )
    {
        len = (float32)(y - pZone->zoneCenterY1);
    }
    else
    {
        // 点と直線の距離の公式
        len = fabs(a*(float32)x + b*(float32)y + c) / sqrt(a*a + b*b);
    }

    return(labs((sint32)len));

}

//---------------------------------------------------------------------------
/**
 * テスト用
 */
//---------------------------------------------------------------------------
void ClippingArea_ChangeAbsolutePosition(StructZone *zone)
{
    float32 theta, cs, sn;
    float32 x1[NUM_ZONE_VERTEX],y1[NUM_ZONE_VERTEX];
    float32 x2[NUM_ZONE_VERTEX],y2[NUM_ZONE_VERTEX];
    int     i;

    for( i=0; i<NUM_ZONE_VERTEX; i++)
    {
        x1[i] = (float32)zone->x[i];
        y1[i] = (float32)zone->y[i];
        theta = Tools_circular2rad(TruckInfo_GetHeading());

        // 車両の方位角だけ回転させる
        cs = cosf(theta); sn = sinf(theta);
        x2[i] = x1[i] * cs - y1[i] * sn;
        y2[i] = x1[i] * sn + y1[i] * cs;

        // 平行移動
        x2[i] += (float32)TruckInfo_GetX();
        y2[i] += (float32)TruckInfo_GetY();

        zone->x[i] = (sint32)x2[i];
        zone->y[i] = (sint32)y2[i];
    }

    zone->zoneCenterX1 = (sint32)( (x2[0] + x2[3]) * 0.5 );
    zone->zoneCenterY1 = (sint32)( (y2[0] + y2[3]) * 0.5 );
    zone->zoneCenterX2 = (sint32)( (x2[1] + x2[2]) * 0.5 );
    zone->zoneCenterY2 = (sint32)( (y2[1] + y2[2]) * 0.5 );
}
//---------------------------------------------------------------------------
/**
 *
 */
//---------------------------------------------------------------------------
sint16 ClippingArea_PrintfZoneData(sint16 index)
{
    char str[128];
    
    if( index < clippingArea.num )
    {
        if( index==0 )
        {
            CanDebugPrintf("ClippingArea");
        }
        
        my_sprintf(str," [%d]",index);
        CanDebugPrintf(str);

        my_sprintf(str," x=[%l %l %l %l]", clippingArea.zone[index].x[0],
                                          clippingArea.zone[index].x[1],
                                          clippingArea.zone[index].x[2],
                                          clippingArea.zone[index].x[3]);
        CanDebugPrintf(str);
        my_sprintf(str," y=[%l %l %l %l]", clippingArea.zone[index].y[0],
                                          clippingArea.zone[index].y[1],
                                          clippingArea.zone[index].y[2],
                                          clippingArea.zone[index].y[3]);
        CanDebugPrintf(str);
        return(0);
    }
    else
    {
        return(-1);
    }
}
//---------------------------------------------------------------------------
/**
 * クリッピングエリア内にあるかどうか
 * @param x 調べる点のX座標 [mm]
 * @param y 調べる点のY座標 [mm]
 * @retval TRUE エリア内
 * @retval FALSE エリア外
 */
//---------------------------------------------------------------------------
bool ClippingArea_IsInsideZone(StructZone *zone, sint32 x, sint32 y )
{
    sint16  hits = 0;
    sint16  i,j,n;
    sint32  ySave = 0;
    sint32  dx,dy;
    sint32  rx,ry;
    float32   s;

    if((x>=zone->minx) && (x<=zone->maxx) && (y>=zone->miny) && (y<=zone->maxy))
    {
        hits=0;
        ySave=0;

        /* Find a vertex that's not on the halfline */
        i = 0;
        while(i < NUM_ZONE_VERTEX && zone->y[i] == y)
        {
            i++;
        }
        
        // まずありえないが、iがNUM_ZONE_VERTEXに等しい（すべての点が同一水平線上）
        // の場合はエリア外とする
        if( i == NUM_ZONE_VERTEX ) 
        {
            return(FALSE);
        }

        /* Walk the edges of the polygon */
        for(n = 0; n < NUM_ZONE_VERTEX; n++)
        {
            j = (i + 1) % NUM_ZONE_VERTEX;

            dx = zone->x[j] - zone->x[i];
            dy = zone->y[j] - zone->y[i];

            /* Ignore horizontal edges completely */
            if( dy != 0 )
            {
                /* Check to see if the edge intersects */

                /* the horizontal halfline through (x, y) */
                rx = x - zone->x[i];
                ry = y - zone->y[i];

                /* Deal with edges starting or ending on the halfline */
                if(zone->y[j] == y && zone->x[j] >= x)
                {
                    ySave = zone->y[i];
                }
        
                if(zone->y[i] == y && zone->x[i] >= x)
                {
                    if((ySave > y) != (zone->y[j] > y))
                    {
                        hits--;
                    }
                }

                /* Tally intersections with halfline */
                s = (float32)ry / (float32)dy;
                if(s >= 0.0 && s <= 1.0 && (s * dx) >= rx)
                {
                    hits++;
                }
            }

            i = j;
        }

        /* Inside if number of intersections odd */
        if( hits%2 != 0 )
        {
            // クリッピングエリア内の横方向の位置を計算する
            return(TRUE);
        }

    }

    // エリアの外側
    return(FALSE);
}

//---------------------------------------------------------------------------
/**
 * テスト用、常に前方に矩形のクリッピングエリアを持つ
 */
//---------------------------------------------------------------------------
void ClippingArea_SetZoneTestWithGlobalCoordinate(void)
{
    sint16 i;
    sint32 width, xs, dx;
    
    // テスト用絶対座標でのクリッピングエリア
    if( ( clippingArea.type == zoneTest4 ) || (clippingArea.type == zoneTestRear2) )
    {
        width = ClippingArea_GetZoneWidth(clippingArea.type) * 100;
        xs    = 0;      // 0m

		if( clippingArea.type == zoneTestRear2 ) 
		{
	        dx = -5000;
		}
		else
		{
	        dx = 5000;
		}

        // セット
        for( i=0; i<clippingArea.num; i++ )
        {
            clippingArea.zone[i].x[0] = xs + dx*i;
            clippingArea.zone[i].x[1] = xs + dx*(i+1);
            clippingArea.zone[i].x[2] = xs + dx*(i+1);
            clippingArea.zone[i].x[3] = xs + dx*i;
            
            clippingArea.zone[i].y[0] = -width;
            clippingArea.zone[i].y[1] = -width;
            clippingArea.zone[i].y[2] = width;
            clippingArea.zone[i].y[3] = width;
            
            clippingArea.zone[i].zoneCenterX1 = clippingArea.zone[i].x[0];
            clippingArea.zone[i].zoneCenterX2 = clippingArea.zone[i].x[1];
            clippingArea.zone[i].zoneCenterY1 = 0;
            clippingArea.zone[i].zoneCenterY2 = 0;

            clippingArea.zone[i].index       = 0;

            if( i == clippingArea.num-1 )
            {
                clippingArea.zone[i].segmentType = ZONE_ACCURATE_STOP;
            }
            else
            {
                if( clippingArea.type == zoneTestRear2 )
                {
                    clippingArea.zone[i].segmentType = ZONE_MOVE_REVERSE;
                }
                else
                {
                    clippingArea.zone[i].segmentType = ZONE_MOVE_FORWARD;
                }
            }

            // 車両の方位角、XY座標だけ変換する
            ClippingArea_ChangeAbsolutePosition(&clippingArea.zone[i]);

            // クリッピングエリアの最大値、最小値
            ClippingArea_CalcBounds(&clippingArea.zone[i]);

            // クリッピングエリアの最大値、最小値
            ClippingArea_CalcBounds(&clippingArea.zone[i]);
        }
    }
}


